/*
실수의 표현 방식
컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡합니다.
왜냐하면, 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표현해야 하기 때문입니다.
따라서 실수를 표현하기 위한 다양한 방법들이 연구되었으며, 
현재에는 다음과 같은 방식이 사용되고 있습니다.
 
1. 고정 소수점(fixed point) 방식
2. 부동 소수점(floating point) 방식

고정 소수점(fixed point) 방식

실수는 보통 정수부와 소수부로 나눌 수 있습니다.
따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현하는 것입니다.
32비트 실수를 고정 소수점 방식으로 표현하면 다음과 같습니다.
부호 1비트
정수부 15비트
소수부 16비트

이 방식은 정수부와 소수부의 자릿수가 크지 않으므로,
표현할 수 있는 범위가 매우 적다는 단점이 있습니다.


부동 소수점(floating point) 방식
실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있습니다.
부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식입니다.
앞서 살펴본 고정 소수점 방식은 제한된 자릿수로 인해 표현할 수 있는 범위가 매우 작습니다.
하지만 부동 소수점 방식은 다음 수식을 이용하여 매우 큰 실수까지도 표현할 수 있습니다
부호 1비트
지수부 8비트
가수부 23비트


이 예시는 10진법을 기반으로 한 부동 소수점 방식으로 0.123을 표현한 것이다.
그런데, IEEE754의 float은 2진법을 기반으로 한다. 이는 (밑) 부분이 10이 아니라 2가 됨을 의미한다.
그렇다면, float의 세 가지 영역에 대해 자세히 살펴보도록 하자.
우선 맨 앞의 Sign 비트는 1일 경우 음수를 나타내고, 0일 경우 양수를 나타낸다. 
Exponent는 말그대로 (지수) 부분을 나타낸다.
단, 주의해야 할 점은 실제 (지수) 값에 127이라는 Bias를 더한 값을 저장하고 있다는 것이다.
예를 들어, 지수가 3인 경우 float의 Exponent 부분을 출력해보면 130이라는 값이 나온다.
따라서 실제 지수 값을 얻으려면 Exponent에서 127을 빼주면 된다.
마지막으로 Mantissa는 (가수) 부분을 나타낸다. 이진수의 경우 이 (가수) 부분에서의 정수 부분은 항상 1이 된다.
즉, 무조건 1.xxx와 같은 형태로 나타난다.
가장 왼쪽에 위치한 1을 기준으로 정수 부분이 한 자리수가 되도록 만들어주기 때문이다.
이러한 특성을 이용해 1비트를 절약하기 위하여 Mantissa에는 소수점 아래의 값들만 저장한다.
예를 들어, 1.11011이라는 수의 Mantissa는 맨 왼쪽의 1을 제외한 11011이 된다.
고정 소수점으로 변환할 때 이 점을 주의해야 한다.
이 정보를 바탕으로 고정 소수점으로 변환해주는 함수를 만들도록 하자.
그런데, 구현에 앞서 한 가지 짚고 넘어가야 할 것이 있다.
단순히 특정 위치에 있는 비트를 읽어서 처리를 하면 간단할 것 같지만,
 C++에서는 float으로 선언한 변수에 대해 비트 연산(Bitwise Operation)을 사용할 수 없다. 
 물론, 특정 위치의 비트에 접근조차 불가능하다. 
 하지만, 이는 기본으로 제공되는 ieee754.h 헤더파일을 통해 해결이 가능하다. 
 ieee754.h에는 IEEE754 표준을 따르는 float의 Sign, Exponent, Mantissa 부분에 접근할 수 있도록 해주는
  ieee754_float이라는 union이 정의되어 있다. 
  이를 통해 원하는 영역의 비트들을 int형으로 받아올 수 있다.

앞서 고정 소수점의 정의 부분에서 언급했듯이, 이 글에서는 이진법을 기반으로 하면서 2의 보수법을 통해 부호를 표현하는 고정 소수점을 구현한다.
*/