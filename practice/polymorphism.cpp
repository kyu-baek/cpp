

/*

바인딩 (binding)
	변수와 함수에 대한 메모리 할당이나 함수 호출이 발생했을 때 
	실제로 처리해야 하는 명령어들이 결정되는 시점

	-정적(static) 바인딩, early
		컴파일 시 변수의 위치와 함수가 실행할 명령이 결정되는 경우
		static 변수나 overloading의 경우
	-동적(dynamic) 바인딩, late
		run time 때 결정이 되는 경우
		지역변수나 overriding의 경우



//가상함수
	-오버라이딩을 구현하는 방법
	-동적 바인딩 (런타임시)
	-가상함수를 정의하기 위해 기본 클래스 멤버함수 앞에 버추얼이라고 쓴다
	-가상함수는 하나의 이름으로 여러개의 수단과 방법을 제공하는 객체지향 프로그래밍의 다형성을 구현하는 한 방법
	-기본 클래스에서 상속 받았는데 파생 클래스에서 멤버함수를 재정의 하는 이유는
		어떠한 경우라도 기본 클래스의 멤버함수를 버리고 파생클래스의 멤버함수를 사용하려는 것
	-기존 클래스의 모든 내용을 모두 현재 프로그램에 사용할 수 있는데 특정 함수가 걸맞지 않을 경우,
		기존 클래스를 고치느니 상속을 받고 가상함수를 이용하여 맘에 들지 않는 함수만 고쳐서 사용함


	가상함수란?
	가상함수는 부모 클래스에서 상속받을 클래스에서 재정의할 것으로 기대하고 정의해놓은 함수입니다. 
	virtual이라는 예약어를 함수 앞에 붙여서 생성할 수 있으며 이렇게 생성된 
	가상함수는 파생 클래스에서 재정의하면 이전에 정의되었던 내용들은 모두 새롭게 정의된 내용들로 교체됩니다

	생성자 함수에서는 객체 자신을 초기화 할 때만 쓴다.
	파생생성자에서는 부모 데이터를 초기화하는 것이 불가능!!!

	오버로딩(Overloading) : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술

	오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용



	# up casting

	- 업캐스팅이란 파생 클래스의 객체를 기본 클래스의 포인터로 가리키는 것을 말한다.
	- 업캐스팅은 파생 클래스의 객체를 기본 클래스의 객체처럼 다룰 수 있게 한다.

	**C++/소멸자에 virtual을 쓰는 이유**

	먼저 *상속을 받은 클래스*의 **생성**과 **소멸** 과정을 보자. 
	**생성자**는 *부모 클래스의 생성자*에서 *자식 클래스의 생성자* 순서로 불려지고, 
	**소멸자**는 *자식 클래스의 소멸자*가 먼저 불려지고 나서 *부모 클래스의 소멸자*가 불려진다.

	그런데 다형성을 이용하기 위해 부모 클래스의 포인터로 자식 클래스를 호출할 때, 
	*가상 함수로 정의되어 있지 않은 자식 클래스의 오버라이딩된 함수*를 호출하면 부모 클래스의 멤버 함수가 호출된다. 
	소멸자도 자식 클래스에서 오버라이딩된 함수라고 볼 수 있기 때문에 
	만약 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출된다.

	*따라서 소멸자를 가상 함수로 선언하지 않으면 이 경우 자식 클래스의 소멸자는 결코 호출되지 않는다*. 
	가상 함수 키워드 `virtual`이 사용되었다면 이것은 자식 클래스에서 재정의될 수 있음을 명시하기 때문에
	 포인터의 종류에 상관없이 항상 자식 클래스의 메서드가 호출된다. 
	 즉, 자식 클래스의 소멸자가 호출되고 나서 부모 클래스의 소멸자가 호출된다.

	따라서 상속 관계가 있고 소멸자에서 리소스를 해제해야 하는 경우 반드시 소멸자를 가상 함수로 선언해야 한다.
*/

#include <iostream>

class A
{
public:
	//1. virtual int ss(int i){return (i*2);}
	int ss(int i){return (i*2);}
	//dd함수 안 내용에서 연결된 ss함수는 컴파일 당시 바로 위 ss함수를 호출하도록 미리 지정되어 있다!!!!!!!
	int dd(int i){return (ss(i)*2);}
};

class B: public A
{
public:
	int ss(int i) {return (i*3);} //재정의 되었지만 이 코드에서는 사용되지 못함 1.의 주석을 지우면 됨

};

int main()
{
	B bb;
	A *pA = new A;
	A *pB = new B; //부모 클래스의 포인터는 자식 클래스를 가질 수 있다.

	std::cout << bb.dd(2) << std::endl;
	std::cout << pA->dd(2) <<std::endl;
	std::cout << pB->dd(2) <<std::endl;

	delete pA;
	delete pB;
	return 0;


}