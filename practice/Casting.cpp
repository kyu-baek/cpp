#include <iostream>


/*
1. static_cast 
static_cast는 dynamic_cast와 다르게 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 뿐만 아니라, 
기초 클래스의 포인터 및 참조형 데이터도 유도 클래스의 포인터 및 참조형 데이터로 아무런 조건 없이 형 변환시켜주지만, 
그에 대한 책임은 프로그래머가 져야 한다.

그리고 static_cast는 기본 자료형 데이터 간의 형 변환에도 사용이 되지만
C언어의 형 변환 연산자는 다음과 같이 정말 일반적이지 않는 형 변환도 허용하기 때문에 static_cast 연산자의 사용을 권한다
*/

class A
{
public:
	void print()
	{std::cout << "A print"<< std::endl;} 
};

class B
{
public:
	void print()
	{std::cout << "B print"<< std::endl;} 
};

int main()
{
	A *a = new A();
	B *b = (B*)a; //c 스타일 캐스팅
	b->print(); //클래스 b의 print 함수를 상대주소로 찾아내서 잘 프린트해주고 있다.
				//이것은 실제로는 아주 위험한 상황.

	B *b2 = static_cast<B*>(a); //둘 사이에는 아무 연관이 없으므로
								//컴파일 단계에서 에러를 발생시켜준다.
	delete a;

}

/*

2. reinterpret_cast

reinterpret_cast<바꿀 타입>(대상)

new_type 유형의 값을 리턴합니다.
static 캐스팅과 같이 컴파일 타임 지시문.

기본적으로 reinterpret_cast는 임의의 포인터 타입끼리 변환을 허용하는 캐스트 연산자 입니다. 
또한 정수형을 포인터로 바꿀 수도 있습니다. (이때 정수값이 포인터의 절대 주소로 들어가게 됩니다. -> 위험)
대상에 해당하는 것을 바꿀 타입으로 바꿀때 비트 단위로 바꾼다. 

******
cast중 가장 쎈놈? 입니다. cast방식은 포인터 -> 포인터, 포인터 -> 일반변수, 일반변수 -> 포인터로
주로 포인터 관련된 cast입니다. 단, 자료형 -> 다른 자료형은 안됩니다.

reinterpret_cast는 형변환이 이뤄지게 되면 해당 자료형의 bit수에 맞게 들어가게 됩니다.
하지만 int * -> char -> int *로 간다면?? 주소값이 파괴되어 nullptr을 가르키게 됩니다.
char형은 1바이트크기여서 주소 값을 다 표현하지 못하기 때문입니다.
이는 reinterpret_cast에 특징 떄문인데, 이녀석은 자료를 그대로 변수로 전달하게 됩니다.(bit 단위로)
때문에 int * -> unsigned int or long -> int * 같은 경우에는 데이터가 그대로 유지되게 됩니다.
주소 값을 모두다 채울 수 있는 크기이기 때문이죠. 하지만 char는 바이트 수가 작기 때문에 데이터를 옮기는 과정에서
dump가 되버려 원본 데이터가 파괴 되는 것이죠.

이녀석은 (void *)로도 전달이 가능하기 때문에 특수한 경우에 쓰입니다.
주로 패킷통신할 때 자료를 포인터로 받아올 때 reinterpret_cast를 사용하게 되며 그 외엔 잘 사용하지 않는걸로 알고 있습니다.
사용가능한 범위를 생각해 본다면.... C <-> C++간의 low레벨에서 사용할 것 같네요....
*****

reinterpret 캐스팅을 사용하면 다음과 같은 변환 만 수행 할 수 있습니다.
1) 정수, 열거 형, 포인터 또는 포인터-투-멤버 유형의 표현은 자체 유형으로 변환 될 수 있습니다. 결과 값은 expression 값과 같습니다 . (C ++ 11부터)
2) 포인터는 그 타입의 모든 값을 담을 수있을 정도로 큰 일체형으로 변환 될 수 있습니다 (예 : std::uintptr_t )
3) 정수 또는 열거 유형의 값을 포인터 유형으로 변환 할 수 있습니다. 충분한 크기의 정수로 변환되고 동일한 포인터 유형으로 다시 변환되는 포인터는 원래 값을 갖도록 보장됩니다. 그렇지 않으면 결과 포인터를 안전하게 참조 해제 할 수 없습니다 (반대 방향의 왕복 변환은 보장되지 않습니다. 동일한 포인터 다중 정수 표현이있는 경우) 널 포인터 상수 NULL 또는 정수 0은 목표 유형의 널 포인터 값을 산출하지 않습니다. 이를 위해 static_cast 또는 암시 적 변환을 사용해야합니다.
4) nullptr 을 포함하여 std::nullptr_t 유형의 모든 값은 마치 (void*)0 인 것처럼 일체형 유형으로 변환 될 수 있지만 nullptr 조차 std::nullptr_t 로 변환 할 수 없는 값은 없습니다 : static_cast 를 사용해야합니다 그 목적을 위해. (C ++ 11부터)
5) 모든 객체 포인터 유형 T1* 은 다른 객체 포인터 유형 cv T2* 로 변환 될 수 있습니다 . 이는 static_cast<cv T2*>(static_cast<cv void*>(expression)) ( T2 의 정렬 요구 사항이 T1 보다 엄격 하지 않은 경우 포인터 값이 변경되지 않고 변환되지 않음을 의미 함) 결과 포인터를 원래 유형으로 되 돌리면 원래 값이 생성됩니다. 어쨌든 결과 포인터는 허용 된 경우에만 안전하게 참조 해제 될 수 있습니다.타입 앨리어싱규칙 (아래 참조)
6) 유형 T1 의 lvalue 표현식은 다른 유형 T2 를 참조하도록 변환 될 수 있습니다 . 결과는 원래 lvalue와 동일한 객체를 참조하지만 유형이 다른 lvalue 또는 xvalue입니다. 임시 생성, 복사, 생성자 또는 변환 함수가 호출되지 않습니다. 결과 참조는 허용 된 경우에만 안전하게 액세스 할 수 있습니다.타입 앨리어싱규칙 (아래 참조)
7) 함수에 대한 포인터는 다른 함수 유형에 대한 포인터로 변환 될 수 있습니다. 다른 함수 유형에 대한 포인터를 통해 함수를 호출하는 것은 정의되어 있지 않지만 해당 포인터를 원래 함수 유형으로 다시 변환하면 원래 함수에 대한 포인터가 생성됩니다.
8) 일부 구현에서 (특히 dlsym 에서 요구하는 POSIX 호환 시스템에서 ) 함수 포인터는 void* 또는 다른 객체 포인터 로 변환 되거나 그 반대로 변환 될 수 있습니다 . 구현이 양방향 변환을 지원하는 경우 원래 유형으로 변환하면 원래 값이 생성됩니다. 그렇지 않으면 결과 포인터를 역 참조하거나 안전하게 호출 할 수 없습니다.
9) 모든 포인터 유형의 널 포인터 값을 다른 포인터 유형으로 변환하여 해당 유형의 널 포인터 값을 생성 할 수 있습니다. 널 포인터 상수 nullptr 또는 std::nullptr_t 유형의 다른 값은 reinterpret_cast 를 사용하여 포인터로 변환 할 수 없습니다 . 암시 적 변환 또는 static_cast 를이 목적으로 사용해야합니다.
10) 멤버 함수에 대한 포인터는 다른 유형의 다른 멤버 함수에 대한 포인터로 변환 될 수 있습니다. 원래 유형으로 다시 변환하면 원래 값이 생성되고, 그렇지 않으면 결과 포인터를 안전하게 사용할 수 없습니다.
11) 어떤 클래스 T1 의 멤버 오브젝트에 대한 포인터는 다른 클래스 T2 의 다른 멤버 오브젝트에 대한 포인터로 변환 될 수 있습니다 . 경우 T2 의 정렬이보다 엄격 T1 의 "원래 형으로 변환 다시 T1 은 별도로 생성 된 포인터를 안전하게 사용할 수없고, 원래의 값을 산출한다.
모든 캐스트 표현식과 마찬가지로 결과는 다음과 같습니다.

new_type이 lvalue 참조 유형이거나 함수 유형에 대한 rvalue 참조 인 경우 lvalue;
new_type이 객체 유형에 대한 rvalue 참조 인 경우 xvalue;
그렇지 않으면 prvalue

*/




/*

3. dynamic_cast
dynamic_cast는 런타임에 (동적으로) 상속 계층 관계를 가로지르거나 다운캐스팅시 사용되는 캐스팅 연산자입니다.
캐스팅의 실패는 NULL(포인터)이거나 예외(참조자)를 보고 판별할 수 있습니다. 
상속 관계에 있지만 virtual 멤버 함수가 하나도 없다면 다형성을 가진게 아니라 단형성이며, 
dynamic_cast는 다형성을 띄지 않은 객체간 변환은 불가능하며, 시도시 컴파일 에러가 발생합니다.

dynamic_cast<바꿀 타입>(대상)

다이나믹 캐스팅에서는 바꿀 타입으로 객체의 포인터 또는 참조형이 와야한다!


dynamic_cast는 다음과 같은 상황에만 형 변환이 가능하다.
1)상속 관계에 놓여 있는 두 클래스 사이에서 파생 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환하는 경우(자식을 부모로 형변환)
	기초 클래스의 포인터 및 참조형 데이터를 파생 클래스의 포인터 및 참조형 데이터로 바꿀 때 컴파일 에러가 난다.
*/

class Parent{};

class Child : public Parent {};

int main3()
{
	Parent *p = new Child();
	Child *c = dynamic_cast<Child*>(p); //컴파일 에러

	Parent *p2 = new Parent();
	Child *c2 = dynamic_cast<Child*>(p2); //컴파일 에러

	Child *p3 = new Child();
	Parent *c3 = dynamic_cast<Parent*>(p3); //컴파일 성공

	delete p;
	delete p2;
	delete p3;

}


/*
static_cast VS. dynamic_cast

<static_cast> 정적으로 형변환을 해도 아무런 문제가 없다는 것은 이미 어떤 녀석인지 알고 있을 경우에 속할 것이고,
<dynamic_cast> 동적으로 형변환을 시도해 본다는 것은 이 녀석의 타입을 반드시 질의해 봐야 된다는 것을 의미합니다.
RTTI를 해야 하는 경우엔 dynamic_cast를 이용해 런타입의 해당 타입을 명확히 질의해야 하고, 
그렇지 않은 경우엔 static_cast를 사용하여 변환 비용을 줄이는 것이 좋습니다.
static_cast는 동적 타입체크를 하지 않기 때문에...

그럼 dynamic_cast와 static_cast를 정리하면 다음과 같다.

[ 파생 클래스의 포인터 및 참조형 데이터 -> 기초 클래스의 포인터 및 참조형 데이터 ] 형 변환할 경우에는 dynamic_cast 연산자를 사용한다.
[ 기초 클래스의 포인터 및 참조형 데이터 -> 파생 클래스의 포인터 및 참조형 데이터 ] 형 변환할 경우에는 static_cast 연산자를 사용한다.

하지만 dynamic_cast 연산자도 기초 클래스의 포인터 및 참조형 데이터를 파생 클래스의 포인터 및 참조형 데이터로 형 변환을 허용한다.
단, 부모 클래스가 Polymorphic 클래스일 때만 가능하다.
Polymorphic(다형성) 클래스란 하나 이상의 가상 함수를 가진 클래스를 뜻한다.
*/